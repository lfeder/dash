<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Greenhouse Plant Map</title>
<style>
:root {
    --bg-primary: #1a1a2e;
    --bg-secondary: #16213e;
    --bg-card: #0f3460;
    --bg-hover: #1a4a7a;
    --text-primary: #e8e8e8;
    --text-secondary: #a8a8b8;
    --text-accent: #fff;
    --border: #2a3a5e;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    min-height: 100vh;
}

/* Header */
.header {
    background: var(--bg-secondary);
    padding: 8px 20px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 16px;
    flex-wrap: wrap;
    position: sticky;
    top: 0;
    z-index: 100;
}

.header h1 {
    font-size: 1.7rem;
    color: var(--text-accent);
    white-space: nowrap;
}

.header-stats {
    display: flex;
    align-items: center;
    gap: 14px;
    flex-wrap: wrap;
}

.header-stat {
    font-size: 1.1rem;
    color: var(--text-secondary);
}

.header-stat strong {
    color: var(--text-accent);
}

.variety-legend {
    display: flex;
    align-items: center;
    gap: 10px;
}

.variety-chip {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 1.05rem;
    color: var(--text-secondary);
}

.variety-chip-dot {
    width: 12px;
    height: 12px;
    border-radius: 2px;
    flex-shrink: 0;
}

.btn {
    background: var(--bg-card);
    color: var(--text-primary);
    border: 1px solid var(--border);
    padding: 6px 14px;
    border-radius: 6px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: background 0.2s;
}

.btn:hover { background: var(--bg-hover); }


/* Content area */
.content {
    padding: 12px 16px;
}


/* Overview grid — fixed layout matching aerial photo */
.overview-wrapper {
    display: flex;
    gap: 24px;
    align-items: flex-start;
    padding: 12px;
}
.farm-layout {
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: flex-start;
    flex-shrink: 0;
}
.farm-row {
    display: flex;
    gap: 8px;
    align-items: flex-start;
}
.farm-col {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.other-locations {
    display: flex;
    gap: 8px;
    align-items: flex-start;
}
.bip-col {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.section-label {
    font-size: 0.8rem;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 1px;
    margin: 16px 0 6px;
    max-width: 1200px;
    margin-left: auto;
    margin-right: auto;
}

.gh-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 6px 8px;
    transition: border-color 0.15s;
    display: inline-flex;
    flex-direction: column;
    overflow: hidden;
    width: min-content;
}

.gh-card:hover {
    border-color: #4a6a9e;
}

.gh-card-header {
    display: flex;
    flex-wrap: wrap;
    align-items: baseline;
    gap: 0 6px;
    margin-bottom: 4px;
    font-size: 0.8rem;
    color: var(--text-secondary);
}

.gh-card-name {
    font-size: 1rem;
    font-weight: 700;
    color: var(--text-accent);
}

.gh-card-body {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.card-side-label {
    font-size: 0.65rem;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-top: 2px;
}

.card-rows {
    display: flex;
    flex-direction: column;
    gap: 1px;
}

.card-row-bar {
    height: 4px;
    border-radius: 2px;
    min-width: 10px;
    transition: opacity 0.15s;
}

.gh-card:hover .card-row-bar {
    opacity: 0.85;
}

.gh-card-footer {
    margin-top: 4px;
    padding-top: 4px;
    border-top: 1px solid var(--border);
    font-size: 0.65rem;
    color: var(--text-secondary);
    line-height: 1.3;
}

.gh-card-footer strong {
    color: var(--text-accent);
}


/* Tooltip */
.tooltip {
    position: fixed;
    background: #222;
    color: #fff;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 0.85rem;
    pointer-events: none;
    z-index: 1000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    max-width: 350px;
    display: none;
}

/* Scrollbar */
::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: var(--bg-primary); }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: #4a6a9e; }

@media (max-width: 768px) {
    /* Header: stack vertically */
    .header {
        padding: 12px 16px;
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
    }
    .header h1 { font-size: 1.2rem; text-align: center; }
    .btn {
        font-size: 1rem;
        padding: 10px 14px;
        -webkit-tap-highlight-color: transparent;
    }

    /* Content */
    .content { padding: 12px; }

    /* Overview: one card per screen */
    .overview-grid {
        grid-template-columns: 1fr;
        gap: 12px;
    }
    .gh-card {
        padding: 16px;
        min-height: calc(100svh - 180px);
        display: flex;
        flex-direction: column;
    }
    .gh-card-header {
        margin-bottom: 12px;
    }
    .gh-card-name { font-size: 1.4rem; }
    .gh-card-body {
        flex: 1;
        justify-content: center;
        gap: 4px;
    }
    .card-side-label { font-size: 0.8rem; margin-top: 8px; }
    .card-row-bar { height: 7px; border-radius: 3px; }
    .gh-card-footer {
        margin-top: 14px;
        padding-top: 10px;
        font-size: 0.9rem;
        flex-wrap: wrap;
        gap: 4px;
    }

    /* Hide tooltip on touch (unreliable) */
    .tooltip { display: none !important; }
}

</style>
</head>
<body>

<div class="header" id="headerBar">
    <h1>Greenhouse Plant Map</h1>
    <div class="header-stats" id="headerStats"></div>
    <div class="variety-legend" id="headerLegend"></div>
    <button id="toggleBtn" onclick="toggleView()" style="margin-left:auto;padding:4px 12px;border-radius:4px;border:1px solid var(--border);background:var(--bg-card);color:var(--text-primary);cursor:pointer;font-size:0.8rem;white-space:nowrap">Current</button>
</div>

<div class="content" id="content"></div>

<div class="tooltip" id="tooltip"></div>

<script>
// --- Configuration ---
const SHEET_ID = '1ewWyvaXGkRCvZxjUxBOHGY4PKdMHwKeTA5jTIod48LE';
const GID = '1615707612';
const GVIZ_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json;responseHandler:handleSheetResponse&gid=${GID}`;

const COLORS = {"Keiki": "#4CAF50", "Japanese": "#E91E63", "Japanese (5/bag)": "#F8BBD0", "English": "#2196F3", "Mixed": "#FF9800"};

let DATA = {};
let SUMMARY = {};
let GH_NAMES = [];
let MAX_BAGS = 0;
let RAW_ROWS = [];
let VIEW_MODE = 'current'; // 'current' or 'new'

function buildData(rows) {
    const useAlt = VIEW_MODE === 'new';
    const greenhouses = {};

    rows.forEach(row => {
        const bags = useAlt && row.bags2 ? row.bags2 : row.bags;
        const ppb = useAlt && row.plants_per_bag2 ? row.plants_per_bag2 : row.plants_per_bag;
        const variety = useAlt && row.variety2 ? row.variety2 : row.variety;
        const total_plants = bags * ppb;
        if (isNaN(row.row_num) || isNaN(bags) || bags === 0) return;
        const gh = row.greenhouse;
        const sideKey = row.side || 'Main';

        if (!greenhouses[gh]) greenhouses[gh] = { sides: {}, total_plants: 0, total_rows: 0 };
        if (!greenhouses[gh].sides[sideKey]) greenhouses[gh].sides[sideKey] = [];

        greenhouses[gh].sides[sideKey].push({
            row_num: row.row_num,
            bags: bags,
            plants_per_bag: ppb,
            total_plants: total_plants,
            variety: variety,
            color_key: ppb === 5 ? `${variety} (5/bag)` : variety
        });

        greenhouses[gh].total_plants += total_plants;
        greenhouses[gh].total_rows += 1;
    });

    // Sort GHs by GH_CONFIG order, then any extras
    const configOrder = Object.keys(GH_CONFIG);
    const sorted = {};
    configOrder.forEach(name => { if (greenhouses[name]) sorted[name] = greenhouses[name]; });
    Object.keys(greenhouses).forEach(name => { if (!sorted[name]) sorted[name] = greenhouses[name]; });

    // Sort sides within each GH using config sideOrder or alphabetical
    for (const [name, ghData] of Object.entries(sorted)) {
        const order = (GH_CONFIG[name] || {}).sideOrder;
        if (order) {
            const s = {};
            order.forEach(k => { if (ghData.sides[k]) s[k] = ghData.sides[k]; });
            Object.keys(ghData.sides).forEach(k => { if (!s[k]) s[k] = ghData.sides[k]; });
            ghData.sides = s;
        }
    }

    return sorted;
}

function computeSummary(data) {
    let totalPlants = 0;
    const varietyCounts = {};

    for (const ghData of Object.values(data)) {
        totalPlants += ghData.total_plants;
        for (const entries of Object.values(ghData.sides)) {
            for (const entry of entries) {
                varietyCounts[entry.color_key] = (varietyCounts[entry.color_key] || 0) + entry.total_plants;
            }
        }
    }

    return {
        total_plants: totalPlants,
        total_greenhouses: Object.keys(data).length,
        total_rows: Object.values(data).reduce((s, g) => s + g.total_rows, 0),
        variety_counts: varietyCounts
    };
}

// --- Parse Google Visualization API response into rows ---
function parseGvizResponse(response) {
    if (response.status !== 'ok') {
        throw new Error('Google Sheets returned status: ' + response.status);
    }
    const table = response.table;
    const rows = [];
    for (const row of table.rows) {
        const c = row.c;
        // Columns: Greenhouse, Side, Row, Bags, Plants/Bag, Total Plants, Variety, Bags2, Plants/Bag2, Variety2
        const gh = c[0] ? (c[0].v || '') : '';
        if (!gh) continue;
        const bags2 = (c[7] && c[7].v) ? Number(c[7].v) : 0;
        const ppb2 = (c[8] && c[8].v) ? Number(c[8].v) : 0;
        const var2 = (c[9] && c[9].v) ? String(c[9].v) : '';
        rows.push({
            greenhouse: String(gh),
            side: (c[1] && c[1].v) ? String(c[1].v) : 'Main',
            row_num: c[2] ? Number(c[2].v) : 0,
            bags: c[3] ? Number(c[3].v) : 0,
            plants_per_bag: c[4] ? Number(c[4].v) : 0,
            total_plants: c[5] ? Number(c[5].v) : 0,
            variety: (c[6] && c[6].v) ? String(c[6].v) : '',
            bags2: bags2,
            plants_per_bag2: ppb2,
            total_plants2: bags2 * ppb2,
            variety2: var2
        });
    }
    return rows;
}

// --- Global callback for the JSONP-style <script> load ---
function handleSheetResponse(response) {
    try {
        RAW_ROWS = parseGvizResponse(response);
        if (RAW_ROWS.length === 0) throw new Error('No data rows found in the sheet.');

        DATA = buildData(RAW_ROWS);
        SUMMARY = computeSummary(DATA);
        GH_NAMES = Object.keys(DATA);

        MAX_BAGS = 0;
        for (const gh of Object.values(DATA)) {
            for (const entries of Object.values(gh.sides)) {
                for (const entry of entries) {
                    if (entry.bags > MAX_BAGS) MAX_BAGS = entry.bags;
                }
            }
        }

        renderHeader();
        showOverview();
    } catch (err) {
        document.getElementById('content').innerHTML =
            '<div style="text-align:center;padding:60px 20px;color:#e57373;font-size:1.1rem;">' +
            '<p>Failed to process sheet data.</p>' +
            '<p style="font-size:0.9rem;margin-top:10px;color:var(--text-secondary);">' + err.message + '</p>' +
            '</div>';
        console.error('Sheet parse error:', err);
    }
}

function rebuild() {
    DATA = buildData(RAW_ROWS);
    SUMMARY = computeSummary(DATA);
    GH_NAMES = Object.keys(DATA);
    MAX_BAGS = 0;
    for (const gh of Object.values(DATA))
        for (const entries of Object.values(gh.sides))
            for (const entry of entries)
                if (entry.bags > MAX_BAGS) MAX_BAGS = entry.bags;
    renderHeader();
    showOverview();
}

function toggleView() {
    VIEW_MODE = VIEW_MODE === 'current' ? 'new' : 'current';
    const btn = document.getElementById('toggleBtn');
    btn.textContent = VIEW_MODE === 'current' ? 'Current' : 'New';
    btn.style.background = VIEW_MODE === 'new' ? '#4ecca3' : 'var(--bg-card)';
    btn.style.color = VIEW_MODE === 'new' ? '#1a1a2e' : 'var(--text-primary)';
    rebuild();
}

// --- Init: inject <script> to load data (bypasses CORS for file:// URLs) ---
function init() {
    document.getElementById('content').innerHTML =
        '<div style="text-align:center;padding:80px 20px;color:var(--text-secondary);font-size:1.2rem;">Loading data from Google Sheets\u2026</div>';
    const script = document.createElement('script');
    script.src = GVIZ_URL;
    script.onerror = function() {
        document.getElementById('content').innerHTML =
            '<div style="text-align:center;padding:60px 20px;color:#e57373;font-size:1.1rem;">' +
            '<p>Failed to load data from Google Sheets.</p>' +
            '<p style="font-size:0.85rem;margin-top:16px;color:var(--text-secondary);">Make sure the sheet is shared as &ldquo;Anyone with the link&rdquo; can view.</p>' +
            '</div>';
    };
    document.head.appendChild(script);
}

// --- Rendering (unchanged) ---
function renderHeader() {
    const total = SUMMARY.total_plants;
    document.getElementById('headerStats').innerHTML = `
        <span class="header-stat"><strong>${SUMMARY.total_greenhouses}</strong> greenhouses</span>
        <span class="header-stat"><strong>${SUMMARY.total_rows.toLocaleString()}</strong> rows</span>
        <span class="header-stat"><strong>${total.toLocaleString()}</strong> plants</span>
    `;

    function chipHtml(v) {
        const count = SUMMARY.variety_counts[v] || 0;
        if (count === 0) return '';
        const pct = Math.round((count / total) * 100);
        return `<span class="variety-chip"><span class="variety-chip-dot" style="background:${COLORS[v]}"></span>${v} ${count.toLocaleString()} (${pct}%)</span>`;
    }

    document.getElementById('headerLegend').innerHTML =
        chipHtml('Keiki') + chipHtml('Japanese (5/bag)') + chipHtml('Japanese') + chipHtml('English') + chipHtml('Mixed');
}

// Uniform sizing: each row is ROW_W px thick, each bag adds BAG_PX to the row length
const ROW_W = 6;   // px — thickness of one row
const BAG_PX = 6;  // px — length per bag
const SIDE_GAP = 8; // px — sidewalk gap between sides

// --- GH Config ---
// GH_CONFIG: single source of truth for all greenhouse rendering
// vert: bars vertical (true) or horizontal (false)
// sidewalk: 'middle'|'top'|'bottom'|'left' — gap position
// merge: collapse all sheet sides into one section
// alignTop: all bars grow from top
// stackSections: horizontal bars with sections stacked vertically
// sideOrder: explicit ordering of sides from sheet data
// group: 'JTL' or 'BIP'
// heightGroup: GHs sharing this key get uniform section heights
// layout: [row, col] or [row, col, stackPos] position in group grid
const GH_CONFIG = {
    'GH1':     { vert: true,  sidewalk: 'middle', group: 'JTL', heightGroup: 'row2', layout: [1,2] },
    'GH2':     { vert: true,  sidewalk: 'middle', group: 'JTL', heightGroup: 'row2', layout: [1,1] },
    'GH3':     { vert: true,  sidewalk: 'middle', group: 'JTL', heightGroup: 'row2', layout: [1,0] },
    'GH4':     { vert: false, sidewalk: 'middle', group: 'JTL', sideOrder: ['East','West'], layout: [0,0] },
    'GH5':     { vert: true,  sidewalk: 'middle', group: 'JTL', heightGroup: 'row3', sideOrder: ['North','Middle','South'], layout: [2,0] },
    'GH6':     { vert: true,  sidewalk: 'middle', group: 'JTL', heightGroup: 'row3', sideOrder: ['North','Middle','South'], layout: [2,1] },
    'GH7':     { vert: true,  sidewalk: 'bottom', merge: true, group: 'JTL', layout: [2,2,'top'] },
    'GH8':     { vert: true,  sidewalk: 'top',    merge: true, alignTop: true, group: 'JTL', layout: [2,2,'bottom'] },
    'Kona':    { vert: true,  sidewalk: 'middle', group: 'BIP', layout: [0,0] },
    'Kohala':  { vert: false, sidewalk: 'left',   group: 'BIP', layout: [0,1] },
    'Hamakua': { vert: true,  sidewalk: 'top',    alignTop: true, group: 'BIP', layout: [1,0] },
    'Waimea':  { vert: false, sidewalk: 'left',   stackSections: true, group: 'BIP', layout: [1,1] },
    'Hilo':    { vert: false, sidewalk: 'left',   group: 'BIP', layout: [2,1] },
};

const VARIETY_ORDER = ['Keiki', 'Japanese (5/bag)', 'Japanese', 'English', 'Mixed'];
const ABBREV = {'Keiki':'K','English':'E','Japanese':'J4','Japanese (5/bag)':'J5','Mixed':'M'};

// Merge all sheet sides into one section if config says so
function prepSections(name, gh) {
    const cfg = GH_CONFIG[name] || {};
    if (cfg.merge && Object.keys(gh.sides).length > 1) {
        const allRows = [];
        for (const s of Object.keys(gh.sides)) allRows.push(...gh.sides[s]);
        allRows.sort((a, b) => a.row_num - b.row_num);
        gh.sides = { 'Main': allRows };
    }
}

// Get max bar length per side (for uniform height groups)
function getSideHeights(name) {
    const gh = DATA[name];
    if (!gh) return {};
    prepSections(name, gh);
    const h = {};
    for (const [side, entries] of Object.entries(gh.sides))
        h[side] = Math.max(...entries.map(e => e.bags), 0) * BAG_PX;
    return h;
}

function renderCard(name, opts) {
    opts = opts || {};
    const gh = DATA[name];
    if (!gh) return '';
    const cfg = GH_CONFIG[name] || {};
    prepSections(name, gh);

    const v = cfg.vert !== false;
    const stk = cfg.stackSections || false;
    const col = v || stk;                          // body is column-direction
    const sides = col ? Object.keys(gh.sides) : [...Object.keys(gh.sides)].reverse();

    // Aggregate stats
    const vCounts = {};
    let totalBags = 0;
    for (const entries of Object.values(gh.sides)) {
        for (const e of entries) { vCounts[e.color_key] = (vCounts[e.color_key] || 0) + e.total_plants; totalBags += e.bags; }
    }

    // Bar dimensions: vertical bars have height=length, width=thickness; horizontal is swapped
    const lenProp = v ? 'height' : 'width';
    const thkProp = v ? 'width' : 'height';
    const secDir  = v ? 'row-reverse' : 'column';  // how bars stack within a section
    const gapProp = col ? 'height' : 'width';       // sidewalk gap direction
    const padSide = cfg.sidewalk === 'left' ? `padding-left:${SIDE_GAP}px;` : '';

    let html = `<div class="gh-card"><div class="gh-card-header"><span class="gh-card-name">${name}</span>` +
        `<span>${gh.total_rows} rows</span><span>${totalBags.toLocaleString()} bags</span><span>${gh.total_plants.toLocaleString()} plants</span></div>` +
        `<div class="gh-card-body" style="flex-direction:${col ? 'column' : 'row'}">`;

    // Edge sidewalk before bars
    if (cfg.sidewalk === 'top') html += `<div style="height:${SIDE_GAP}px;flex-shrink:0"></div>`;

    sides.forEach((side, i) => {
        if (i > 0) html += `<div style="${gapProp}:${SIDE_GAP}px;flex-shrink:0"></div>`;
        const fixedLen = opts.sideHeights && opts.sideHeights[side];
        const fixStyle = fixedLen ? `${lenProp}:${fixedLen}px;` : '';
        const isLowerSection = cfg.alignTop || (i > 0 && cfg.sidewalk === 'middle') || side === 'South' || side === 'Middle';
        const align = v ? `align-items:${isLowerSection ? 'flex-start' : 'flex-end'};` : '';
        html += `<div style="display:flex;flex-direction:${secDir};gap:1px;${align}${fixStyle}${padSide}">`;
        gh.sides[side].forEach(e => {
            const len = e.bags * BAG_PX;
            const tip = `Row ${e.row_num} · ${e.variety} · ${e.bags} bags · ${e.total_plants} plants`;
            html += `<div style="${lenProp}:${len}px;${thkProp}:${ROW_W}px;border-radius:1px;background:${COLORS[e.color_key]};flex-shrink:0;cursor:pointer" onmouseover="showTooltip(event,'${tip}')" onmousemove="moveTooltip(event)" onmouseout="hideTooltip()"></div>`;
        });
        html += `</div>`;
    });

    // Edge sidewalk after bars
    if (cfg.sidewalk === 'bottom') html += `<div style="height:${SIDE_GAP}px;flex-shrink:0"></div>`;

    html += `</div><div class="gh-card-footer">`;
    VARIETY_ORDER.forEach(va => { if (vCounts[va]) html += `<span style="color:${COLORS[va]}">${ABBREV[va]}:${vCounts[va].toLocaleString()}</span> `; });
    html += `</div></div>`;
    return html;
}

function showOverview() {
    // Compute uniform side heights per heightGroup
    const hg = {};
    for (const [name, cfg] of Object.entries(GH_CONFIG)) {
        if (!cfg.heightGroup) continue;
        if (!hg[cfg.heightGroup]) hg[cfg.heightGroup] = {};
        for (const [side, h] of Object.entries(getSideHeights(name)))
            hg[cfg.heightGroup][side] = Math.max(hg[cfg.heightGroup][side] || 0, h);
    }
    const optsFor = (n) => {
        const g = (GH_CONFIG[n] || {}).heightGroup;
        return g && hg[g] ? { sideHeights: hg[g] } : {};
    };

    // Build grid from layout coords: groups cells by [row, col], handles stacking
    function buildGrid(group) {
        const ghs = Object.entries(GH_CONFIG).filter(([,c]) => c.group === group && c.layout);
        const grid = {};
        ghs.forEach(([name, cfg]) => {
            const [r, c, stackPos] = cfg.layout;
            const key = `${r},${c}`;
            if (!grid[key]) grid[key] = { r, c, items: [] };
            grid[key].items.push({ name, stackPos: stackPos || '' });
        });
        // Sort stacked items
        for (const cell of Object.values(grid))
            cell.items.sort((a, b) => a.stackPos < b.stackPos ? -1 : a.stackPos > b.stackPos ? 1 : 0);
        return grid;
    }

    function renderCell(cell) {
        if (cell.items.length > 1) {
            let h = '<div class="farm-col">';
            cell.items.forEach(it => { h += renderCard(it.name, optsFor(it.name)); });
            return h + '</div>';
        }
        return renderCard(cell.items[0].name, optsFor(cell.items[0].name));
    }

    // Render a group grid: byCols=false → outer=rows, inner=cols; byCols=true → outer=cols, inner=rows
    function renderGrid(group, wrapClass, innerClass, byCols) {
        const grid = buildGrid(group);
        const cells = Object.values(grid);
        if (!cells.length) return '';
        const maxR = Math.max(...cells.map(c => c.r)), maxC = Math.max(...cells.map(c => c.c));
        const [outerMax, innerMax] = byCols ? [maxC, maxR] : [maxR, maxC];
        let html = `<div class="${wrapClass}">`;
        for (let o = 0; o <= outerMax; o++) {
            html += `<div class="${innerClass}">`;
            for (let i = 0; i <= innerMax; i++) {
                const key = byCols ? `${i},${o}` : `${o},${i}`;
                const cell = grid[key];
                if (cell) html += renderCell(cell);
            }
            html += '</div>';
        }
        return html + '</div>';
    }

    let html = '<div class="overview-wrapper">';
    html += renderGrid('JTL', 'farm-layout', 'farm-row', false);
    html += renderGrid('BIP', 'other-locations', 'bip-col', true);
    html += '</div>';
    document.getElementById('content').innerHTML = html;
}


// Tooltip
function showTooltip(e, text) {
    const tip = document.getElementById('tooltip');
    tip.textContent = text;
    tip.style.display = 'block';
    moveTooltip(e);
}

function moveTooltip(e) {
    const tip = document.getElementById('tooltip');
    let x = e.clientX + 12;
    let y = e.clientY + 12;
    // Keep on screen
    const rect = tip.getBoundingClientRect();
    if (x + rect.width > window.innerWidth) x = e.clientX - rect.width - 12;
    if (y + rect.height > window.innerHeight) y = e.clientY - rect.height - 12;
    tip.style.left = x + 'px';
    tip.style.top = y + 'px';
}

function hideTooltip() {
    document.getElementById('tooltip').style.display = 'none';
}

init();
</script>
</body>
</html>